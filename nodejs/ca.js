const path = require('path');
const logger = require('./logger').new('ca-core');
const CAClient = require('fabric-ca-client/lib/FabricCAClientImpl');
const {CryptoPath} = require('./path');
const FABRIC_CA_HOME = '/etc/hyperledger/fabric-ca-server';
exports.container = {
	FABRIC_CA_HOME,
	CONFIG: path.resolve(FABRIC_CA_HOME, 'fabric-ca-server-config.yaml'),
	caKey: path.resolve(FABRIC_CA_HOME, 'ca-key.pem'),
	caCert: path.resolve(FABRIC_CA_HOME, 'ca-cert.pem'),
	tlsCert: path.resolve(FABRIC_CA_HOME, 'tls-cert.pem'),
};
exports.user = {
	register: (caService, {username, affiliation}, adminUser) =>
		registerIfNotExist(caService, {enrollmentID: username, affiliation, role: 'user'}, adminUser),
};
exports.peer = {
	toAdminCerts: ({certificate}, cryptoPath, nodeType) => {
		const {admincerts} = cryptoPath.MSPFile(nodeType);
		CryptoPath.writeFileSync(admincerts, certificate);
	},
};
exports.intermediateCA = {
	register: (caService, {enrollmentID, affiliation}, adminUser) => {

		return caService.register({
			enrollmentID,
			affiliation: affiliation.toLowerCase(),
			role: 'client',
			maxEnrollments: -1,
			attrs: [{name: 'hf.IntermediateCA', value: 'true'}]
		}, adminUser);
	}

};
const registerIfNotExist = async (caService, {enrollmentID, enrollmentSecret, affiliation, role}, adminUser) => {
	try {
		const secret = await caService.register({
			enrollmentID,
			enrollmentSecret,
			role,
			maxEnrollments: -1,
			affiliation
		}, adminUser);
		if (!enrollmentSecret) {
			logger.info('new enrollmentSecret generated by ca service');
			return {enrollmentID, enrollmentSecret: secret, status: 'generated'};
		}
		else return {enrollmentID, enrollmentSecret, status: 'assigned'};
	} catch (err) {
		if (err.toString().includes('is already registered')) {
			return {enrollmentID, enrollmentSecret, status: 'existed'};
		} else {
			throw err;
		}
	}
};
exports.pkcs11_key = {
	generate: (cryptoSuite) => cryptoSuite.generateKey({ephemeral: !cryptoSuite._cryptoKeyStore}),
	toKeystore: (key, dirName) => {
		const filename = `${key._key.prvKeyHex}_sk`;
		const absolutePath = path.resolve(dirName, filename);
		exports.pkcs11_key.save(absolutePath, key);
	},
	save: (path, key) => {
		CryptoPath.writeFileSync(path, key.toBytes());
	}

};

exports.toMSP = ({key, certificate, rootCertificate}, cryptoPath, type) => {
	const {cacerts, keystore, signcerts} = cryptoPath.MSPFile(type);
	CryptoPath.writeFileSync(signcerts, certificate);
	exports.pkcs11_key.toKeystore(key, keystore);
	CryptoPath.writeFileSync(cacerts, rootCertificate);
};
exports.org = {
	saveAdmin: ({certificate, rootCertificate}, cryptoPath, nodeType) => {
		const {ca, msp: {admincerts, cacerts}} = cryptoPath.OrgFile(nodeType);

		CryptoPath.writeFileSync(cacerts, rootCertificate);
		CryptoPath.writeFileSync(ca, rootCertificate);
		CryptoPath.writeFileSync(admincerts, certificate);
	},
	saveTLS: ({rootCertificate}, cryptoPath, nodeType) => {
		const {msp: {tlscacerts}, tlsca} = cryptoPath.OrgFile(nodeType);
		CryptoPath.writeFileSync(tlsca, rootCertificate);
		CryptoPath.writeFileSync(tlscacerts, rootCertificate);
	}
};
exports.toTLS = ({key, certificate, rootCertificate}, cryptoPath, type) => {
	const {caCert, cert, key: serverKey} = cryptoPath.TLSFile(type);
	const {tlscacerts} = cryptoPath.MSPFile(type);//TLS in msp folder
	exports.pkcs11_key.save(serverKey, key);
	CryptoPath.writeFileSync(cert, certificate);
	CryptoPath.writeFileSync(caCert, rootCertificate);
	CryptoPath.writeFileSync(tlscacerts,rootCertificate);
};

exports.register = registerIfNotExist;
/**
 *
 * @param {string} caUrl
 * @param {string[]} trustedRoots
 * @returns {FabricCAServices}
 */
exports.new = (caUrl, trustedRoots = []) => {
	const tlsOptions = {
		trustedRoots,
		verify: trustedRoots.length > 0
	};
	return new CAClient(caUrl, tlsOptions);
};
exports.envBuilder = () => {
	return [
		'GODEBUG=netdns=go',
	];
};